{
    "docs": [
        {
            "location": "/", 
            "text": "REST Framework XML\n\n\nXML support for Django REST Framework\n\n\n\n\nOverview\n\n\nXML support extracted as a third party package directly from the official Django REST Framework implementation. It requires the \ndefusedxml\n package only because it safeguards against some security issues that were discovered.\n\n\nNote\n: XML output provided is an ad-hoc format that isn't formally described. If you have specific XML requirements you'll need to write your own XML parsers/renderers in order to fully control the representation.\n\n\nRequirements\n\n\n\n\nPython (2.7, 3.3, 3.4)\n\n\nDjango (1.6, 1.7)\n\n\nDjango REST Framework (2.4.4, 3.0, 3.1)\n\n\n\n\nInstallation\n\n\nInstall using \npip\n...\n\n\n$ pip install djangorestframework-xml\n\n\n\n\nExample\n\n\nREST_FRAMEWORK = {\n    'DEFAULT_PARSER_CLASSES': (\n        'rest_framework_xml.parsers.XMLParser',\n    ),\n    'DEFAULT_RENDERER_CLASSES': (\n        'rest_framework_xml.renderers.XMLRenderer',\n    ),\n}\n\n\n\n\nYou can also set the renderer and parser used for an individual view, or viewset, using the APIView class based views.\n\n\nfrom rest_framework import routers, serializers, viewsets\nfrom rest_framework_xml.parsers import XMLParser\nfrom rest_framework_xml.renderers import XMLRenderer\n\n\nclass UserSerializer(serializers.HyperlinkedModelSerializer):\n    class Meta:\n        model = User\n        fields = ('url', 'username', 'email', 'is_staff')\n\n\nclass UserViewSet(viewsets.ModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    parser_classes = (XMLParser,)\n    renderer_classes = (XMLRenderer,)\n\n\n\n\nSample output\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\nroot\n\n    \nlist-item\n\n        \nurl\nhttp://127.0.0.1:8000/users/1/.xml\n/url\n\n        \nusername\njpadilla\n/username\n\n        \nemail\njpadilla@example.com\n/email\n\n        \nis_staff\nTrue\n/is_staff\n\n    \n/list-item\n\n\n/root\n\n\n\n\n\nTesting\n\n\nInstall testing requirements.\n\n\n$ pip install -r requirements.txt\n$ pip install -r requirements-test.txt\n\n\n\n\nRun with runtests.\n\n\n$ ./runtests.py\n\n\n\n\nYou can also use the excellent \ntox\n testing tool to run the tests against all supported versions of Python and Django. Install tox globally, and then simply run:\n\n\n$ tox\n\n\n\n\nDocumentation\n\n\nTo build the documentation, you'll need to install \nmkdocs\n.\n\n\n$ pip install mkdocs\n\n\n\n\nTo preview the documentation:\n\n\n$ mkdocs serve\nRunning at: http://127.0.0.1:8000/\n\n\n\n\nTo build the documentation:\n\n\n$ mkdocs build", 
            "title": "Home"
        }, 
        {
            "location": "/#rest-framework-xml", 
            "text": "XML support for Django REST Framework", 
            "title": "REST Framework XML"
        }, 
        {
            "location": "/#overview", 
            "text": "XML support extracted as a third party package directly from the official Django REST Framework implementation. It requires the  defusedxml  package only because it safeguards against some security issues that were discovered.  Note : XML output provided is an ad-hoc format that isn't formally described. If you have specific XML requirements you'll need to write your own XML parsers/renderers in order to fully control the representation.", 
            "title": "Overview"
        }, 
        {
            "location": "/#requirements", 
            "text": "Python (2.7, 3.3, 3.4)  Django (1.6, 1.7)  Django REST Framework (2.4.4, 3.0, 3.1)", 
            "title": "Requirements"
        }, 
        {
            "location": "/#installation", 
            "text": "Install using  pip ...  $ pip install djangorestframework-xml", 
            "title": "Installation"
        }, 
        {
            "location": "/#example", 
            "text": "REST_FRAMEWORK = {\n    'DEFAULT_PARSER_CLASSES': (\n        'rest_framework_xml.parsers.XMLParser',\n    ),\n    'DEFAULT_RENDERER_CLASSES': (\n        'rest_framework_xml.renderers.XMLRenderer',\n    ),\n}  You can also set the renderer and parser used for an individual view, or viewset, using the APIView class based views.  from rest_framework import routers, serializers, viewsets\nfrom rest_framework_xml.parsers import XMLParser\nfrom rest_framework_xml.renderers import XMLRenderer\n\n\nclass UserSerializer(serializers.HyperlinkedModelSerializer):\n    class Meta:\n        model = User\n        fields = ('url', 'username', 'email', 'is_staff')\n\n\nclass UserViewSet(viewsets.ModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    parser_classes = (XMLParser,)\n    renderer_classes = (XMLRenderer,)  Sample output  ?xml version= 1.0  encoding= utf-8 ?  root \n     list-item \n         url http://127.0.0.1:8000/users/1/.xml /url \n         username jpadilla /username \n         email jpadilla@example.com /email \n         is_staff True /is_staff \n     /list-item  /root", 
            "title": "Example"
        }, 
        {
            "location": "/#testing", 
            "text": "Install testing requirements.  $ pip install -r requirements.txt\n$ pip install -r requirements-test.txt  Run with runtests.  $ ./runtests.py  You can also use the excellent  tox  testing tool to run the tests against all supported versions of Python and Django. Install tox globally, and then simply run:  $ tox", 
            "title": "Testing"
        }, 
        {
            "location": "/#documentation", 
            "text": "To build the documentation, you'll need to install  mkdocs .  $ pip install mkdocs  To preview the documentation:  $ mkdocs serve\nRunning at: http://127.0.0.1:8000/  To build the documentation:  $ mkdocs build", 
            "title": "Documentation"
        }, 
        {
            "location": "/parsers/", 
            "text": "Parsers\n\n\nSetting the parsers\n\n\nThe default set of parsers may be set globally, using the \nDEFAULT_PARSER_CLASSES\n setting.  For example, the following settings would allow requests with \nXML\n content.\n\n\nREST_FRAMEWORK = {\n    'DEFAULT_PARSER_CLASSES': (\n        'rest_framework_xml.parsers.XMLParser',\n    )\n}\n\n\n\nYou can also set the parsers used for an individual view, or viewset,\nusing the \nAPIView\n class based views.\n\n\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\nfrom rest_framework_xml.parsers import XMLParser\n\nclass ExampleView(APIView):\n    \"\"\"\n    A view that can accept POST requests with XML content.\n    \"\"\"\n    parser_classes = (XMLParser,)\n\n    def post(self, request, format=None):\n        return Response({'received data': request.DATA})\n\n\n\nOr, if you're using the \n@api_view\n decorator with function based views.\n\n\n@api_view(['POST'])\n@parser_classes((XMLParser,))\ndef example_view(request, format=None):\n    \"\"\"\n    A view that can accept POST requests with XML content.\n    \"\"\"\n    return Response({'received data': request.DATA})\n\n\n\n\n\nAPI Reference\n\n\nXMLParser\n\n\nParses REST framework's default style of \nXML\n request content.\n\n\nNote that the \nXML\n markup language is typically used as the base language for more strictly defined domain-specific languages, such as \nRSS\n, \nAtom\n, and \nXHTML\n.\n\n\nIf you are considering using \nXML\n for your API, you may want to consider implementing a custom renderer and parser for your specific requirements, and using an existing domain-specific media-type, or creating your own custom XML-based media-type.\n\n\nRequires the \ndefusedxml\n package to be installed.\n\n\n.media_type\n: \napplication/xml", 
            "title": "Parsers"
        }, 
        {
            "location": "/parsers/#parsers", 
            "text": "", 
            "title": "Parsers"
        }, 
        {
            "location": "/parsers/#setting-the-parsers", 
            "text": "The default set of parsers may be set globally, using the  DEFAULT_PARSER_CLASSES  setting.  For example, the following settings would allow requests with  XML  content.  REST_FRAMEWORK = {\n    'DEFAULT_PARSER_CLASSES': (\n        'rest_framework_xml.parsers.XMLParser',\n    )\n}  You can also set the parsers used for an individual view, or viewset,\nusing the  APIView  class based views.  from rest_framework.response import Response\nfrom rest_framework.views import APIView\nfrom rest_framework_xml.parsers import XMLParser\n\nclass ExampleView(APIView):\n    \"\"\"\n    A view that can accept POST requests with XML content.\n    \"\"\"\n    parser_classes = (XMLParser,)\n\n    def post(self, request, format=None):\n        return Response({'received data': request.DATA})  Or, if you're using the  @api_view  decorator with function based views.  @api_view(['POST'])\n@parser_classes((XMLParser,))\ndef example_view(request, format=None):\n    \"\"\"\n    A view that can accept POST requests with XML content.\n    \"\"\"\n    return Response({'received data': request.DATA})", 
            "title": "Setting the parsers"
        }, 
        {
            "location": "/parsers/#api-reference", 
            "text": "", 
            "title": "API Reference"
        }, 
        {
            "location": "/parsers/#xmlparser", 
            "text": "Parses REST framework's default style of  XML  request content.  Note that the  XML  markup language is typically used as the base language for more strictly defined domain-specific languages, such as  RSS ,  Atom , and  XHTML .  If you are considering using  XML  for your API, you may want to consider implementing a custom renderer and parser for your specific requirements, and using an existing domain-specific media-type, or creating your own custom XML-based media-type.  Requires the  defusedxml  package to be installed.  .media_type :  application/xml", 
            "title": "XMLParser"
        }, 
        {
            "location": "/renderers/", 
            "text": "Renderers\n\n\nSetting the renderers\n\n\nThe default set of renderers may be set globally, using the \nDEFAULT_RENDERER_CLASSES\n setting.  For example, the following settings would use \nXML\n as the main media type and also include the self describing API.\n\n\nREST_FRAMEWORK = {\n    'DEFAULT_RENDERER_CLASSES': (\n        'rest_framework_xml.renderers.XMLRenderer',\n    )\n}\n\n\n\nYou can also set the renderers used for an individual view, or viewset,\nusing the \nAPIView\n class based views.\n\n\nfrom django.contrib.auth.models import User\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\nfrom rest_framework_xml.renderers import XMLRenderer\n\nclass UserCountView(APIView):\n    \"\"\"\n    A view that returns the count of active users in XML.\n    \"\"\"\n    renderer_classes = (XMLRenderer,)\n\n    def get(self, request, format=None):\n        user_count = User.objects.filter(active=True).count()\n        content = {'user_count': user_count}\n        return Response(content)\n\n\n\nOr, if you're using the \n@api_view\n decorator with function based views.\n\n\n@api_view(['GET'])\n@renderer_classes((XMLRenderer,))\ndef user_count_view(request, format=None):\n    \"\"\"\n    A view that returns the count of active users in XML.\n    \"\"\"\n    user_count = User.objects.filter(active=True).count()\n    content = {'user_count': user_count}\n    return Response(content)\n\n\n\n\n\nAPI Reference\n\n\nXMLRenderer\n\n\nRenders REST framework's default style of \nXML\n response content.\n\n\nNote that the \nXML\n markup language is used typically used as the base language for more strictly defined domain-specific languages, such as \nRSS\n, \nAtom\n, and \nXHTML\n.\n\n\nIf you are considering using \nXML\n for your API, you may want to consider implementing a custom renderer and parser for your specific requirements, and using an existing domain-specific media-type, or creating your own custom XML-based media-type.\n\n\n.media_type\n: \napplication/xml\n\n\n.format\n: \n'.xml'\n\n\n.charset\n: \nutf-8\n\n\nitem_tag_name\n: \nlist-item\n\n\n.root_tag_name\n: \nroot", 
            "title": "Renderers"
        }, 
        {
            "location": "/renderers/#renderers", 
            "text": "", 
            "title": "Renderers"
        }, 
        {
            "location": "/renderers/#setting-the-renderers", 
            "text": "The default set of renderers may be set globally, using the  DEFAULT_RENDERER_CLASSES  setting.  For example, the following settings would use  XML  as the main media type and also include the self describing API.  REST_FRAMEWORK = {\n    'DEFAULT_RENDERER_CLASSES': (\n        'rest_framework_xml.renderers.XMLRenderer',\n    )\n}  You can also set the renderers used for an individual view, or viewset,\nusing the  APIView  class based views.  from django.contrib.auth.models import User\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\nfrom rest_framework_xml.renderers import XMLRenderer\n\nclass UserCountView(APIView):\n    \"\"\"\n    A view that returns the count of active users in XML.\n    \"\"\"\n    renderer_classes = (XMLRenderer,)\n\n    def get(self, request, format=None):\n        user_count = User.objects.filter(active=True).count()\n        content = {'user_count': user_count}\n        return Response(content)  Or, if you're using the  @api_view  decorator with function based views.  @api_view(['GET'])\n@renderer_classes((XMLRenderer,))\ndef user_count_view(request, format=None):\n    \"\"\"\n    A view that returns the count of active users in XML.\n    \"\"\"\n    user_count = User.objects.filter(active=True).count()\n    content = {'user_count': user_count}\n    return Response(content)", 
            "title": "Setting the renderers"
        }, 
        {
            "location": "/renderers/#api-reference", 
            "text": "", 
            "title": "API Reference"
        }, 
        {
            "location": "/renderers/#xmlrenderer", 
            "text": "Renders REST framework's default style of  XML  response content.  Note that the  XML  markup language is used typically used as the base language for more strictly defined domain-specific languages, such as  RSS ,  Atom , and  XHTML .  If you are considering using  XML  for your API, you may want to consider implementing a custom renderer and parser for your specific requirements, and using an existing domain-specific media-type, or creating your own custom XML-based media-type.  .media_type :  application/xml  .format :  '.xml'  .charset :  utf-8  item_tag_name :  list-item  .root_tag_name :  root", 
            "title": "XMLRenderer"
        }
    ]
}